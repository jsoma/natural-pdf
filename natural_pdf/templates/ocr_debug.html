<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR Debug Report</title>
    <style>
        /* CSS content will be injected here */
        /* {css_content} */
    </style>
</head>
<body>
    <h1>OCR Debug Report</h1>
    
    <div class="controls">
        <div class="filter-control">
            <label for="confidence-filter">Min Confidence:</label>
            <input type="range" id="confidence-filter" min="0" max="1" step="0.05" value="0">
            <span id="confidence-value">0.00</span>
        </div>
        
        <div class="filter-control">
            <label for="text-filter">Text Filter:</label>
            <input type="text" id="text-filter" placeholder="Filter text...">
        </div>
        
        <div class="filter-control">
            <label for="sort-by">Sort By:</label>
            <select id="sort-by">
                <option value="position">Position (default)</option>
                <option value="confidence-asc">Confidence (Low to High)</option>
                <option value="confidence-desc">Confidence (High to Low)</option>
                <option value="text-length">Text Length</option>
            </select>
        </div>
        
        <button id="export-json" class="export-btn">Export JSON</button>
    </div>
    
    <div id="pages-container">
        <!-- Pages will be inserted here -->
    </div>
    
    <script>
        // Main OCR data structure with pages and regions
        // Data will be injected here by the Python script
        const ocrData = {pages_data_json}; // Use placeholder for JSON data
        
        // ===== DOM Elements =====
        const pagesContainer = document.getElementById('pages-container');
        const confidenceFilter = document.getElementById('confidence-filter');
        const confidenceValue = document.getElementById('confidence-value');
        const textFilter = document.getElementById('text-filter');
        const sortBySelect = document.getElementById('sort-by');
        const exportButton = document.getElementById('export-json');
        
        // ===== Rendering Functions =====
        
        // Render a single page section with its regions
        function renderPage(page, pageIndex) {
            const pageDiv = document.createElement('div');
            pageDiv.className = 'page-section';
            pageDiv.id = `page-${pageIndex}`;
            
            // Page header with controls
            const pageTitle = document.createElement('div');
            pageTitle.className = 'page-title';
            
            const pageHeading = document.createElement('h2');
            pageHeading.textContent = `Page ${page.page_number}`;
            pageTitle.appendChild(pageHeading);
            
            const pageControls = document.createElement('div');
            pageControls.className = 'page-controls';
            
            const toggleImageBtn = document.createElement('button');
            toggleImageBtn.className = 'toggle-btn';
            toggleImageBtn.textContent = 'Show Full Image';
            toggleImageBtn.onclick = () => toggleFullImage(pageIndex);
            pageControls.appendChild(toggleImageBtn);
            
            pageTitle.appendChild(pageControls);
            pageDiv.appendChild(pageTitle);
            
            // Full page image (hidden by default)
            const pageImage = document.createElement('img');
            pageImage.src = page.image;
            pageImage.className = 'page-image';
            pageImage.id = `page-image-${pageIndex}`;
            pageImage.alt = `Page ${page.page_number}`;
            pageDiv.appendChild(pageImage);
            
            // Table for regions
            const table = document.createElement('table');
            table.className = 'region-table';
            
            // Table header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            
            // Add data-label attribute for mobile view
            const headers = [
                { label: 'Confidence', mobileLabel: 'Conf.' },
                { label: 'Text Region', mobileLabel: 'Region' },
                { label: 'Text Content', mobileLabel: 'Content' }
            ];
            headers.forEach(headerInfo => {
                const th = document.createElement('th');
                th.textContent = headerInfo.label;
                // Store mobile label if needed later, although CSS uses data-label on TD
                headerRow.appendChild(th);
            });
            
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Table body
            const tbody = document.createElement('tbody');
            tbody.id = `regions-${pageIndex}`;
            
            // Render each region row
            page.regions.forEach((region, regionIndex) => {
                const row = renderRegionRow(region, pageIndex, regionIndex, page.image);
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            pageDiv.appendChild(table);
            
            return pageDiv;
        }
        
        // Render a single region row
        function renderRegionRow(region, pageIndex, regionIndex, pageImage) {
            const row = document.createElement('tr');
            row.className = 'region-row';
            row.dataset.confidence = region.confidence;
            row.dataset.text = region.ocr_text; // Original text
            row.dataset.modified = (region.modified || false).toString();
            row.dataset.regionId = `${pageIndex}-${regionIndex}`;
            
            // Confidence cell
            const confidenceCell = document.createElement('td');
            confidenceCell.className = 'confidence';
            confidenceCell.textContent = region.confidence.toFixed(2);
            confidenceCell.dataset.label = 'Confidence'; // Label for mobile view
            
            // Set color level based on confidence
            if (region.confidence >= 0.8) {
                confidenceCell.dataset.level = 'high';
            } else if (region.confidence >= 0.5) {
                confidenceCell.dataset.level = 'medium';
            } else {
                confidenceCell.dataset.level = 'low';
            }
            
            row.appendChild(confidenceCell);
            
            // Image region cell
            const imageCell = document.createElement('td');
            imageCell.className = 'region-image';
            imageCell.dataset.label = 'Text Region'; // Label for mobile view
            
            const imageClip = document.createElement('div');
            imageClip.className = 'image-clip';
            imageClip.style.backgroundImage = `url('${pageImage}')`;
            
            // Calculate dimensions (scaled by 2.0 to match the image scale used in python)
            const imgScale = 2.0; // Should match _get_page_image_base64 scale
            const width = (region.bbox[2] - region.bbox[0]) * imgScale;
            const height = (region.bbox[3] - region.bbox[1]) * imgScale;
            
            // Calculate background position (negative of the top-left corner, scaled)
            imageClip.style.backgroundPosition = `-${region.bbox[0] * imgScale}px -${region.bbox[1] * imgScale}px`;
            
            // If the image is very large, we'll apply CSS transform scaling instead of 
            // changing the dimensions directly to maintain proper background position
            const maxWidth = 350;
            const maxHeight = 250;
            let scale = 1;
            
            if (width > maxWidth || height > maxHeight) {
                const scaleX = maxWidth / width;
                const scaleY = maxHeight / height;
                scale = Math.min(scaleX, scaleY);
                imageClip.style.transform = `scale(${scale})`;
            }
            
            // Set the final dimensions
            imageClip.style.width = `${width}px`;
            imageClip.style.height = `${height}px`;
            
            imageCell.appendChild(imageClip);
            row.appendChild(imageCell);
            
            // Combined text content cell with textarea
            const textCell = document.createElement('td');
            textCell.className = 'text-content';
            textCell.dataset.label = 'Text Content'; // Label for mobile view
            
            const textArea = document.createElement('textarea');
            textArea.className = 'text-content-input';
            textArea.value = region.corrected_text || region.ocr_text; // Use corrected if available
            textArea.rows = Math.max(1, Math.ceil((region.corrected_text || region.ocr_text).length / 40)); // Approximate rows
            textArea.dataset.pageIndex = pageIndex;
            textArea.dataset.regionIndex = regionIndex;
            textArea.dataset.originalText = region.ocr_text;
            
            // Add initial modified class if needed
            if (textArea.value !== region.ocr_text) {
                textArea.classList.add('modified');
            }

            // --- NEW: Select text on focus ---
            textArea.addEventListener('focus', (e) => {
                e.target.select();
            });

            // --- NEW: Handle Enter key press ---
            textArea.addEventListener('keydown', handleEnterNavigation);

            // Save changes to data structure
            textArea.addEventListener('input', (e) => {
                const pIdx = parseInt(e.target.dataset.pageIndex);
                const rIdx = parseInt(e.target.dataset.regionIndex);
                const currentVal = e.target.value;
                const originalVal = e.target.dataset.originalText;
                
                ocrData.pages[pIdx].regions[rIdx].corrected_text = currentVal;
                
                // Update the modified status in the dataset and visual style
                const isModified = currentVal !== originalVal;
                ocrData.pages[pIdx].regions[rIdx].modified = isModified;
                row.dataset.modified = isModified.toString(); // Update row dataset too
                
                // Visual indication of modification through textarea style
                if (isModified) {
                    e.target.classList.add('modified');
                } else {
                    e.target.classList.remove('modified');
                }
                
                // Update text filter immediately if it's active
                if (textFilter.value) {
                    filterByText(textFilter.value);
                }
            });
            
            textCell.appendChild(textArea);
            row.appendChild(textCell);
            
            return row;
        }
        
        // ===== Interactive Functions =====
        
        // Toggle display of full page image
        function toggleFullImage(pageIndex) {
            const image = document.getElementById(`page-image-${pageIndex}`);
            const button = image.previousElementSibling.querySelector('.toggle-btn');
            
            if (!image || !button) return; // Safety check
            
            if (image.classList.contains('show')) {
                image.classList.remove('show');
                button.textContent = 'Show Full Image';
            } else {
                image.classList.add('show');
                button.textContent = 'Hide Full Image';
            }
        }
        
        // --- NEW: Function to handle Enter key navigation ---
        function handleEnterNavigation(event) {
            if (event.key === 'Enter') {
                event.preventDefault(); // Stop newline insertion

                const allTextAreas = Array.from(document.querySelectorAll('.text-content-input'));
                const currentIndex = allTextAreas.indexOf(event.target);

                if (currentIndex > -1 && currentIndex < allTextAreas.length - 1) {
                    // Focus the next text area if it exists
                    const nextTextArea = allTextAreas[currentIndex + 1];
                    nextTextArea.focus(); // Focus will trigger the select() behavior
                }
                // Optional: else if (currentIndex === allTextAreas.length - 1) { /* Focus first? */ }
            }
        }
        
        // Combined filter function
        function applyFilters() {
            const minConfidence = parseFloat(confidenceFilter.value);
            const searchText = textFilter.value.toLowerCase();
            
            document.querySelectorAll('.region-row').forEach(row => {
                const confidence = parseFloat(row.dataset.confidence);
                const textarea = row.querySelector('.text-content-input');
                const currentText = textarea ? textarea.value.toLowerCase() : row.dataset.text.toLowerCase();
                
                const confidenceMatch = confidence >= minConfidence;
                const textMatch = !searchText || currentText.includes(searchText);
                
                if (confidenceMatch && textMatch) {
                    row.classList.remove('hidden');
                } else {
                    row.classList.add('hidden');
                }
            });
        }
        
        // Sort regions by different criteria
        function sortRegions(sortBy) {
            ocrData.pages.forEach((page, pageIndex) => {
                const tbody = document.getElementById(`regions-${pageIndex}`);
                if (!tbody) return; // Safety check
                const rows = Array.from(tbody.querySelectorAll('.region-row'));
                
                // Sort based on selected criterion
                rows.sort((a, b) => {
                    const confA = parseFloat(a.dataset.confidence);
                    const confB = parseFloat(b.dataset.confidence);
                    const textA = a.querySelector('.text-content-input')?.value || a.dataset.text;
                    const textB = b.querySelector('.text-content-input')?.value || b.dataset.text;
                    
                    switch (sortBy) {
                        case 'confidence-asc':
                            return confA - confB;
                        case 'confidence-desc':
                            return confB - confA;
                        case 'text-length':
                            // Sort by length of current text in textarea
                            return (textB?.length || 0) - (textA?.length || 0);
                        case 'position':
                        default:
                            // Default sort by region ID (original position)
                            const idA = a.dataset.regionId.split('-').map(Number);
                            const idB = b.dataset.regionId.split('-').map(Number);
                            if (idA[0] !== idB[0]) return idA[0] - idB[0]; // Page index
                            return idA[1] - idB[1]; // Region index
                    }
                });
                
                // Reinsert in sorted order
                rows.forEach(row => tbody.appendChild(row));
            });
        }
        
        // Export data as JSON
        function exportJSON() {
            // Create a structure with only the data needed for export
            const exportStructure = {
                pages: ocrData.pages.map(page => ({
                    page_number: page.page_number,
                    regions: page.regions.map(region => ({
                        id: region.id,
                        bbox: region.bbox,
                        ocr_text: region.ocr_text,
                        corrected_text: region.corrected_text,
                        confidence: region.confidence,
                        modified: region.modified
                    }))
                }))
            };
            
            // Create a downloadable JSON with the filtered structure
            const exportData = JSON.stringify(exportStructure, null, 2);
            const blob = new Blob([exportData], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'ocr_debug_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // ===== Event Listeners =====
        
        confidenceFilter.addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            confidenceValue.textContent = value.toFixed(2);
            applyFilters(); // Apply combined filters
        });
        
        textFilter.addEventListener('input', () => {
            applyFilters(); // Apply combined filters
        });
        
        sortBySelect.addEventListener('change', (e) => {
            sortRegions(e.target.value);
        });
        
        exportButton.addEventListener('click', exportJSON);
        
        // ===== Initialize =====
        
        // Render all pages
        if (ocrData && ocrData.pages) {
            ocrData.pages.forEach((page, i) => {
                const pageElement = renderPage(page, i);
                pagesContainer.appendChild(pageElement);
            });
        } else {
            console.error("ocrData is not defined or has no pages property. Check Python injection.");
            // Optionally display an error message to the user in the UI
            pagesContainer.innerHTML = '<p style="color: red;">Error: Could not load OCR data.</p>';
        }
        
        // Initial filter application
        applyFilters();
    </script>
</body>
</html>